/*
 * Bearsampp Module Composer - Gradle Build
 *
 * Full Gradle build process for Composer module
 * Based on module-apache template
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release -PbundleVersion=2.8.10     - Build release for specific version
 *   gradle releaseAll                         - Build all versions
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 *   gradle verify                             - Verify build environment
 *   gradle listVersions                       - List available versions
 *   gradle listReleases                       - List releases from properties
 */

plugins {
    id 'base'
}

// ============================================================================
// PROPERTIES AND CONFIGURATION
// ============================================================================

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'composer')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'composer')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'tools')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // Build paths - CRITICAL: Output destination based on bundle.type
    // For tools: D:/Bearsampp-dev/bearsampp-build/tools/{bundleName}/{bundleRelease}
    // For bins: D:/Bearsampp-dev/bearsampp-build/bins/{bundleName}/{bundleRelease}
    def customBuildPath = buildProps.getProperty('build.path', 'D:/Bearsampp-dev/bearsampp-build')
    buildBinsPath = file("${customBuildPath}/${bundleType}/${bundleName}/${bundleRelease}").absolutePath

    // Temporary build directories
    bundleTmpPath = file("${projectDir}/build").absolutePath
    bundleTmpDownloadPath = file("${bundleTmpPath}/downloads").absolutePath
    bundleTmpExtractPath = file("${bundleTmpPath}/extract").absolutePath
    bundleTmpPrepPath = file("${bundleTmpPath}/prep").absolutePath

    // Modules untouched path
    modulesUntouchedPath = file("${rootDir}/modules-untouched").absolutePath
}

// Load modules untouched properties
def untouchedProps = new Properties()
def untouchedFile = file("${ext.modulesUntouchedPath}/modules/${ext.bundleName}.properties")
if (untouchedFile.exists()) {
    untouchedFile.withInputStream { untouchedProps.load(it) }
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    throw new GradleException("Dev path not found: ${ext.devPath}. Please ensure the 'dev' project exists in ${ext.rootDir}")
}

// Configure repositories
repositories {
    mavenCentral()
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Helper function to generate hash files
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }

    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash} ${file.name}\n"
    println "  Created: ${md5File.name}"

    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash} ${file.name}\n"
    println "  Created: ${sha1File.name}"

    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash} ${file.name}\n"
    println "  Created: ${sha256File.name}"

    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash} ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// ============================================================================
// TASKS
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    // Capture values at configuration time
    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def javaVersion = JavaVersion.current()
    def javaHome = System.getProperty('java.home')
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                  Bearsampp Module Composer - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          Build Output: ${buildBinsPath}
          Temp Build:   ${bundleTmpPath}

        Java:
          Version:      ${javaVersion}
          Home:         ${javaHome}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification tasks

        Quick Start:
          gradle tasks                            - List all available tasks
          gradle info                             - Show this information
          gradle release -PbundleVersion=2.8.10   - Build specific version
          gradle releaseAll                       - Build all versions
          gradle clean                            - Clean build artifacts
          gradle verify                           - Verify build environment
          gradle listVersions                     - List available versions
        """.stripIndent()
    }
}

// Task: Main release task - build a specific version
tasks.register('release') {
    group = 'build'
    description = 'Build release package for a specific version (use -PbundleVersion=X.X.X)'

    doLast {
        def versionToBuild = project.findProperty('bundleVersion')

        if (!versionToBuild) {
            throw new GradleException("""
                Bundle version not specified!

                Usage: gradle release -PbundleVersion=X.X.X

                Example: gradle release -PbundleVersion=2.8.10

                Run 'gradle listVersions' to see available versions.
            """.stripIndent())
        }

        println ""
        println "=".multiply(70)
        println "Building ${bundleName} ${versionToBuild} release package"
        println "=".multiply(70)
        println ""

        // Verify bundle path exists
        def bundlePath = file("${projectDir}/bin/${bundleName}${versionToBuild}")

        if (!bundlePath.exists()) {
            def availableVersions = file("${projectDir}/bin").listFiles()
                ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                ?.collect { it.name.replace(bundleName, '') }
                ?.sort() ?: []

            throw new GradleException("""
                Bundle version not found: ${bundlePath}

                Available versions in bin/:
                ${availableVersions.collect { "  - ${it}" }.join('\n')}
            """.stripIndent())
        }

        println "Bundle path: ${bundlePath}"
        println ""

        // Get the bundle folder name and version
        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        // Prepare output directory
        def composerPrepPath = file("${bundleTmpPrepPath}/${bundleName}${bundleVersion}")
        if (composerPrepPath.exists()) {
            delete composerPrepPath
        }
        composerPrepPath.mkdirs()

        println "Output directory: ${composerPrepPath}"
        println ""

        // Get composer.phar URL from untouched properties
        def composerPharUrl = untouchedProps.getProperty(bundleVersion)
        if (!composerPharUrl) {
            throw new GradleException("Composer.phar URL not found for version ${bundleVersion} in modules-untouched/modules/composer.properties")
        }

        println "Downloading composer.phar from: ${composerPharUrl}"

        // Download composer.phar
        def downloadDir = file(bundleTmpDownloadPath)
        if (!downloadDir.exists()) {
            downloadDir.mkdirs()
        }

        def composerPharFile = file("${bundleTmpDownloadPath}/${bundleVersion}-composer.phar")
        if (!composerPharFile.exists()) {
            println "  Downloading to: ${composerPharFile}"
            ant.get(src: composerPharUrl, dest: composerPharFile, verbose: true)
            println "  Download completed"
        } else {
            println "  Using cached file: ${composerPharFile}"
        }
        println ""

        // Copy composer.phar to prep directory
        println "Copying composer.phar..."
        copy {
            from composerPharFile
            into composerPrepPath
            rename { 'composer.phar' }
        }
        println "  composer.phar copied successfully"
        println ""

        // Copy configuration files from bundle
        println "Copying ${bundleName} configuration files..."
        copy {
            from bundlePath
            into composerPrepPath
        }
        println "  Configuration files copied successfully"
        println ""

        // Create final output directory
        def outputDir = file(buildBinsPath)
        if (!outputDir.exists()) {
            outputDir.mkdirs()
            println "Created output directory: ${outputDir}"
        }

        // Determine archive filename and path
        def destFile = "${buildBinsPath}/bearsampp-${bundleName}-${bundleVersion}-${bundleRelease}"

        // Compress based on format
        if (bundleFormat == '7z') {
            // 7z format
            def archiveFile = file("${destFile}.7z")
            if (archiveFile.exists()) {
                delete archiveFile
            }

            println "Compressing ${bundleName}${bundleVersion} to ${archiveFile.name}..."

            // Find 7zip executable - try dev path first, then system path
            def sevenZipPath = file("${devPath}/bin/7zip/7za.exe")
            if (!sevenZipPath.exists()) {
                sevenZipPath = file("C:/Program Files/7-Zip/7z.exe")
                if (!sevenZipPath.exists()) {
                    throw new GradleException("7zip not found. Please install 7-Zip or place 7za.exe in ${devPath}/bin/7zip/")
                }
            }

            // Execute 7zip compression (compress from parent directory to include folder structure)
            def command = [
                sevenZipPath.absolutePath,
                'a',
                '-t7z',
                archiveFile.absolutePath.toString(),
                bundleFolder
            ]

            def process = new ProcessBuilder(command as String[])
                .directory(file(bundleTmpPrepPath))
                .redirectErrorStream(true)
                .start()

            process.inputStream.eachLine { line ->
                if (line.trim()) println "  ${line}"
            }

            def exitCode = process.waitFor()
            if (exitCode != 0) {
                throw new GradleException("7zip compression failed with exit code: ${exitCode}")
            }

            println "Archive created: ${archiveFile}"

            // Generate hash files
            println "Generating hash files..."
            generateHashFiles(archiveFile)

        } else {
            // ZIP format
            def archiveFile = file("${destFile}.zip")
            if (archiveFile.exists()) {
                delete archiveFile
            }

            println "Compressing ${bundleName}${bundleVersion} to ${archiveFile.name}..."

            ant.zip(destfile: archiveFile, basedir: file(bundleTmpPrepPath), includes: "${bundleFolder}/**")

            println "Archive created: ${archiveFile}"

            // Generate hash files
            println "Generating hash files..."
            generateHashFiles(archiveFile)
        }

        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println "Output directory: ${buildBinsPath}"
        println "Archive: ${destFile}.${bundleFormat}"
        println "=".multiply(70)
    }
}

// Task: Build all available versions
tasks.register('releaseAll') {
    group = 'build'
    description = 'Build release packages for all available versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            throw new GradleException("bin/ directory not found")
        }

        def versions = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') }
            ?.sort() ?: []

        if (versions.isEmpty()) {
            throw new GradleException("No versions found in bin/ directory")
        }

        println ""
        println "=".multiply(70)
        println "Building releases for ${versions.size()} ${bundleName} versions"
        println "=".multiply(70)
        println ""

        def successCount = 0
        def failedVersions = []

        versions.each { version ->
            println "=".multiply(70)
            println "[${successCount + 1}/${versions.size()}] Building ${bundleName} ${version}..."
            println "=".multiply(70)

            try {
                // Call the release task logic for this version
                def bundlePath = file("${projectDir}/bin/${bundleName}${version}")

                if (!bundlePath.exists()) {
                    throw new GradleException("Bundle path not found: ${bundlePath}")
                }

                println "Bundle path: ${bundlePath}"
                println ""

                // Get the bundle folder name and version
                def bundleFolder = bundlePath.name
                def bundleVersion = bundleFolder.replace(bundleName, '')

                // Prepare output directory
                def composerPrepPath = file("${bundleTmpPrepPath}/${bundleName}${bundleVersion}")
                if (composerPrepPath.exists()) {
                    delete composerPrepPath
                }
                composerPrepPath.mkdirs()

                // Copy all files from bundle
                println "Copying ${bundleName} files..."
                copy {
                    from bundlePath
                    into composerPrepPath
                }

                // Create final output directory
                def outputDir = file(buildBinsPath)
                if (!outputDir.exists()) {
                    outputDir.mkdirs()
                }

                // Determine archive filename and path
                def destFile = "${buildBinsPath}/bearsampp-${bundleName}-${bundleVersion}-${bundleRelease}"

                // Compress based on format
                if (bundleFormat == '7z') {
                    def archiveFile = file("${destFile}.7z")
                    if (archiveFile.exists()) {
                        delete archiveFile
                    }

                    println "Compressing ${bundleName}${bundleVersion} to ${archiveFile.name}..."

                    // Find 7zip executable - try dev path first, then system path
                    def sevenZipPath = file("${devPath}/bin/7zip/7za.exe")
                    if (!sevenZipPath.exists()) {
                        sevenZipPath = file("C:/Program Files/7-Zip/7z.exe")
                        if (!sevenZipPath.exists()) {
                            throw new GradleException("7zip not found. Please install 7-Zip or place 7za.exe in ${devPath}/bin/7zip/")
                        }
                    }

                    def command = [
                        sevenZipPath.absolutePath,
                        'a',
                        '-t7z',
                        archiveFile.absolutePath.toString(),
                        '.'
                    ]

                    def process = new ProcessBuilder(command as String[])
                        .directory(composerPrepPath)
                        .redirectErrorStream(true)
                        .start()

                    process.inputStream.eachLine { line ->
                        if (line.trim()) println "  ${line}"
                    }

                    def exitCode = process.waitFor()
                    if (exitCode != 0) {
                        throw new GradleException("7zip compression failed with exit code: ${exitCode}")
                    }

                    println "Archive created: ${archiveFile}"
                    generateHashFiles(archiveFile)

                } else {
                    def archiveFile = file("${destFile}.zip")
                    if (archiveFile.exists()) {
                        delete archiveFile
                    }

                    println "Compressing ${bundleName}${bundleVersion} to ${archiveFile.name}..."
                    ant.zip(destfile: archiveFile, basedir: composerPrepPath)
                    println "Archive created: ${archiveFile}"
                    generateHashFiles(archiveFile)
                }

                println ""
                println "[SUCCESS] ${bundleName} ${version} completed"
                println "Output: ${composerPrepPath}"
                successCount++

            } catch (Exception e) {
                println ""
                println "[FAILED] ${bundleName} ${version}: ${e.message}"
                failedVersions.add(version)
            }

            println ""
        }

        // Summary
        println "=".multiply(70)
        println "Build Summary"
        println "=".multiply(70)
        println "Total versions: ${versions.size()}"
        println "Successful:     ${successCount}"
        println "Failed:         ${failedVersions.size()}"

        if (!failedVersions.isEmpty()) {
            println ""
            println "Failed versions:"
            failedVersions.each { v ->
                println "  - ${v}"
            }
        }

        println "=".multiply(70)

        if (failedVersions.isEmpty()) {
            println "[SUCCESS] All versions built successfully!"
        } else {
            throw new GradleException("${failedVersions.size()} version(s) failed to build")
        }
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
        }

        println "[SUCCESS] Build artifacts cleaned"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-composer..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()

        // Check dev directory
        checks['dev directory'] = file(devPath).exists()

        // Check 7zip if format is 7z
        if (bundleFormat == '7z') {
            def devSevenZip = file("${devPath}/bin/7zip/7za.exe").exists()
            def systemSevenZip = file("C:/Program Files/7-Zip/7z.exe").exists()
            checks['7zip executable'] = devSevenZip || systemSevenZip
        }

        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release -PbundleVersion=2.8.10   - Build release for version"
            println "  gradle releaseAll                        - Build all versions"
            println "  gradle listVersions                      - List available versions"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        def releasesFile = file('releases.properties')
        if (!releasesFile.exists()) {
            println "releases.properties not found"
            return
        }

        def releases = new Properties()
        releasesFile.withInputStream { releases.load(it) }

        println "\nAvailable Composer Releases:"
        println "-".multiply(80)
        releases.sort { it.key }.each { version, url ->
            println "  ${version.padRight(10)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${releases.size()}"
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        def versions = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') }
            ?.sort() ?: []

        println "\nAvailable ${bundleName} versions in bin/:"
        println "-".multiply(60)
        versions.each { version ->
            println "  ${version}"
        }
        println "-".multiply(60)
        println "Total versions: ${versions.size()}"

        if (!versions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${versions.last()}"
        }
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println "Validating build.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: Show build output destination
tasks.register('showDestination') {
    group = 'help'
    description = 'Show where build artifacts will be output'

    doLast {
        println "\nBuild Output Configuration:"
        println "-".multiply(60)
        println "Bundle Type:    ${bundleType}"
        println "Bundle Format:  ${bundleFormat}"
        println "Output Path:    ${buildBinsPath}"
        println ""
        println "Archives will be created at:"
        println "  ${buildBinsPath}/bearsampp-${bundleName}-<version>-${bundleRelease}.${bundleFormat}"
        println "-".multiply(60)
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module Composer - Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
